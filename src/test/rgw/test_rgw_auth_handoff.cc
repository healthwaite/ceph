// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
// vim: ts=8 sw=2 smarttab

#include <cstdint>
#include <iostream>
#include <optional>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include <absl/random/random.h>
#include <boost/algorithm/hex.hpp>
#include <boost/regex.hpp>
#include <fmt/format.h>
#include <gmock/gmock-matchers.h>
#include <grpc/grpc.h>
#include <grpcpp/channel.h>
#include <grpcpp/client_context.h>
#include <grpcpp/create_channel.h>
#include <gtest/gtest.h>
#include <openssl/evp.h>

#include "authenticator/v1/authenticator.pb.h"
#include "common/async/yield_context.h"
#include "common/ceph_argparse.h"
#include "common/ceph_json.h"
#include "common/dout.h"
#include "common/strtol.h"
#include "global/global_context.h"
#include "global/global_init.h"
#include "include/ceph_assert.h"
#include "rgw/rgw_b64.h"
#include "rgw/rgw_client_io.h"
#include "rgw/rgw_handoff.h"
#include "rgw/rgw_handoff_impl.h"
#include "rgw/rgw_http_client.h"

#include "test_rgw_grpc_util.h"

// These are 'standard' protobufs for the 'Richer error model'
// (https://grpc.io/docs/guides/error/).
#include "google/rpc/error_details.pb.h"
#include "google/rpc/status.pb.h"

// This is the protobuf for the authenticator service, copied from
// obj-endpoint.
#include "authenticator/v1/authenticator.grpc.pb.h"

/*
 * Tools tests.
 */

namespace {

/* #region TestData */

// The information we need to use an access key.
struct AccessKeyInfo {
  std::string userid;
  std::string secret;
};

static std::unordered_map<std::string, AccessKeyInfo>
    super_secret_vault = {
      // This is the 'testid' user created by many tests, and installed by
      // default into dbstore.
      { "0555b35654ad1656d804", { "testid", "h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==" } },
      { "AKIAIOSFODNN7EXAMPLE", { "awsquerystringexample", "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" } }
    };

// Look up the userid and secret for a given credential (access key id).
static std::optional<AccessKeyInfo>
info_for_credential(const std::string& access_key)
{
  auto srch = super_secret_vault.find(access_key);
  if (srch == super_secret_vault.end()) {
    return std::nullopt;
  }
  return std::make_optional(srch->second);
}

struct HandoffHdrTestData {
  std::string name;
  /// @brief The string_to_sign field.
  std::string ss_base64;
  std::string access_key;
  std::string signature;
  std::string authorization;
};

static HandoffHdrTestData sigpass_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature.
        {
            "s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "0555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature.
        {
            "dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature.
        {
            "s3cmd ls s3://test (empty -> v2 auth)",
            "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

HandoffHdrTestData sigfail_tests[]
    = {
        // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature. stringToSign corrupted, but carefully
        // since it's base64 encoded - if we just randomly corrupt it, we
        // might get invalid utf-8 which upsets gRPC.
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNjgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMgo=",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        }, // This is generated by `s3cmd ls s3://test` with the bucket test
        // pre-created. V4 signature. access_key corrupted (but note it's the
        // same wrong value in the authorization header - RGW would normally
        // parse the access key out of the header, and it's confusing to have
        // it wrong in the access key field but correct in the header).
        {
            "xfail (access_key): s3cmd ls s3://test",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMFQxNjQ1MzJaCjIwMjMwNzEwL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNTgxYzA3NzEzYjRmODFjYmQ4YTFiN2NhN2ZiNzU4YTkyMzVmYzQyYzZjZmZjZDgyMTIxNjdiMjA2NmJjODIwMg==",
            "1555b35654ad1656d804",
            "616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
            "AWS4-HMAC-SHA256 Credential=1555b35654ad1656d804/20230710/us-east-1/s3/aws4_request,SignedHeaders=host;x-amz-content-sha256;x-amz-date,Signature=616427c5112796fde309f6620ae2542b6c493e7c84026771d2e9f94af2b5150b",
        },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Signature corrupted.
        {
            "xfail (sig): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/us-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=1c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `dd if=/dev/urandom bs=4096 count=1 | s3cmd put - s3://test/rand1`
        // V4 signature. Authorization header corrupted.
        {
            "xfail (authhdr): dd ... | s3cmd put - s3://test/rand1",
            "QVdTNC1ITUFDLVNIQTI1NgoyMDIzMDcxMVQxNDMwMTRaCjIwMjMwNzExL3VzLWVhc3QtMS9zMy9hd3M0X3JlcXVlc3QKNGQ1ZDg2N2NiODBmMmU3Y2FlMGM5YmZmMWUxYTE4YmYyMmJjMmY4NWYzYjVjNzY0Nzg1MTYzNTA4MjljODhkZQ",
            "0555b35654ad1656d804",
            "0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c",
            "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20230711/xs-east-1/s3/aws4_request,SignedHeaders=content-length;host;x-amz-content-sha256;x-amz-date,Signature=0c7838f249db0668d832d78feb1a3fd55606dbe0e630592411c83f18ed8d465c" },
        // This is generated by
        //   `s3cmd ls s3://test` with nothing in the bucket.
        // V2 signature. stringToSign corrupted.
        {
            "xfail (v2 access key): s3cmd ls s3://test (empty -> v2 auth)",
            "00VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
            "0555b35654ad1656d804",
            "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
            "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE=" }
      };

// This is generated by
//   `s3cmd ls s3://test` with nothing in the bucket.
// V2 signature.
HandoffHdrTestData v2_sample = {
  "v2_sample",
  "R0VUCgoKCngtYW16LWRhdGU6VHVlLCAxMSBKdWwgMjAyMyAxNzoxMDozOCArMDAwMAovdGVzdC8=",
  "0555b35654ad1656d804",
  "ZbQ5cA54KqNak3O2KTRTwX5YzUE=",
  "AWS 0555b35654ad1656d804:ZbQ5cA54KqNak3O2KTRTwX5YzUE="
};

struct HandoffQueryTestData {
  std::string name;
  std::string access_key;
  std::string presignedUrl;
};

HandoffQueryTestData presigned_pass_tests[] = {
  { "'s3cmd signurl s3://testnv/rand +3600' at 1696590328",
      "0555b35654ad1656d804",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1696593928&Signature=2yvZEGjagY%2B5nyk9IcBOR%2Bu5KT8%3D" }
};

/* #endregion */
/* #region SupportCode */

namespace ba = boost::algorithm;

#define SSL_CHAR_CAST(x) reinterpret_cast<const unsigned char*>(x)

// Wrap the rigmarole of hashing a buffer with OpenSSL.
static std::optional<std::vector<uint8_t>> _hash_by(const std::vector<uint8_t>& key, const std::string& input, const std::string& hash_type)
{
  auto pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key.data(), key.size());
  auto md = EVP_get_digestbyname(hash_type.c_str());
  auto ctx = EVP_MD_CTX_new();
  if (!EVP_DigestSignInit(ctx, NULL, md, NULL, pkey)) {
    std::cerr << "HMAC ctx init failed" << std::endl;
    return std::nullopt;
  }
  if (!EVP_DigestSignUpdate(ctx, input.data(), input.size())) {
    std::cerr << "HMAC update failed" << std::endl;
    return std::nullopt;
  }
  std::vector<uint8_t> hash(EVP_MD_size(md));
  size_t hsiz = hash.size();
  if (!EVP_DigestSignFinal(ctx, hash.data(), &hsiz) || static_cast<int>(hsiz) != EVP_MD_size(md)) {
    std::cerr << "HMAC final failed" << std::endl;
    return std::nullopt;
  }
  EVP_MD_CTX_free(ctx);
  return std::make_optional(hash);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v4_auth { "^AWS4-HMAC-SHA256\\sCredential=(?<accesskey>[0-9a-f]+)/(?<date>\\d+)"
                                 "/(?<region>[0-9a-z-]+)"
                                 "/(?<service>[0-9a-z-]+)"
                                 "/aws4_request"
                                 ",SignedHeaders=(?<signhdr>[-;a-z0-9]+)"
                                 ",Signature=(?<sig>[0-9a-f]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs.
 */
static std::optional<std::string> verify_aws_v4_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format(FMT_STRING("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'"), string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v4_auth)) {
    std::cerr << "no match v4" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrdate = m.str("date");
  auto hdrregion = m.str("region");
  auto hdrservice = m.str("service");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = "AWS4" + secret_key;
  std::vector<uint8_t> init;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(init));

  // Hash each step.
  auto datekey = _hash_by(init, hdrdate, "SHA256");
  if (!datekey) {
    return std::nullopt;
  }
  auto dateregionkey = _hash_by(*datekey, hdrregion, "SHA256");
  if (!dateregionkey) {
    return std::nullopt;
  }
  auto dateregionservicekey = _hash_by(*dateregionkey, hdrservice, "SHA256");
  if (!dateregionservicekey) {
    return std::nullopt;
  }
  auto signingkey = _hash_by(*dateregionservicekey, "aws4_request", "SHA256");
  if (!signingkey) {
    return std::nullopt;
  }

  // Step 3.
  auto sigbytes = _hash_by(*signingkey, string_to_sign, "SHA256");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  boost::algorithm::hex_lower(*sigbytes, std::back_inserter(sigstr));

  // Compare the signature to that in the header.
  if (sigstr != hdrsig) {
    std::cerr << fmt::format(FMT_STRING("signature mismatch got='{}' expected='{}'"), sigstr, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sigstr);
}

// Match the fields out of the V4 Authorization header.
static boost::regex re_v2_auth { "^AWS\\s(?<accesskey>[0-9a-f]+):"
                                 "(?<sig>[^ \t]+)"
                                 "$" };

/* Given the inputs, generate an AWS v4 signature and return as an
 * optional<string>. In case of problems, return nullopt.
 *
 * This is the part the authenticator normally performs.
 */
static std::optional<std::string> verify_aws_v2_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  // std::cerr << fmt::format(FMT_STRING("get_aws_v4_hash(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'"), string_to_sign, access_key_id, secret_key, authorization) << std::endl;

  boost::smatch m;
  if (!boost::regex_match(authorization, m, re_v2_auth)) {
    std::cerr << "no match V2" << std::endl;
    return std::nullopt;
  }
  auto hdrakid = m.str("accesskey");
  auto hdrsig = m.str("sig");

  // Step 1 is in string_to_sign.

  // Step 2.
  auto initstr = secret_key;
  std::vector<uint8_t> signingkey;
  // Create a vec<uint8_t> of the initial secret. The _hash() function can
  // then chain input to output more easily without excessive conversions.
  std::copy(initstr.begin(), initstr.end(), std::back_inserter(signingkey));

  // Step 3.
  auto sigbytes = _hash_by(signingkey, string_to_sign, "SHA1");
  if (!sigbytes) {
    return std::nullopt;
  }

  // Hex encode the signature.
  std::string sigstr;
  std::copy((*sigbytes).begin(), (*sigbytes).end(), std::back_inserter(sigstr));
  auto sig_b64 = rgw::to_base64(sigstr);

  // Compare the signature to that in the header.
  if (sig_b64 != hdrsig) {
    std::cerr << fmt::format(FMT_STRING("signature mismatch got='{}' expected='{}'"), sig_b64, hdrsig) << std::endl;
    return std::nullopt;
  }

  return std::make_optional(sig_b64);
}

// Given an Authorization header (v2 or v4), extract and return the access key
// id. Return nullopt on any error.
static std::optional<std::string> extract_access_key_id_from_authorization_header(const std::string authorization)
{
  if (ba::starts_with(authorization, "AWS ")) {
    boost::smatch m;
    if (!boost::regex_match(authorization, m, re_v2_auth)) {
      std::cerr << "no match V2" << std::endl;
      return std::nullopt;
    }
    return std::make_optional(m.str("accesskey"));

  } else {
    boost::smatch m;
    if (!boost::regex_match(authorization, m, re_v4_auth)) {
      std::cerr << "no match v4" << std::endl;
      return std::nullopt;
    }
    return std::make_optional(m.str("accesskey"));
  }
}

// Examine the Authorization header. If it starts with 'AWS ', call the v2
// signature handler. Otherwise call the v4 handler.
static std::optional<std::string> verify_aws_signature(std::string string_to_sign, std::string secret_key, std::string authorization)
{
  if (ba::starts_with(authorization, "AWS ")) {
    return verify_aws_v2_signature(string_to_sign, secret_key, authorization);
  } else {
    return verify_aws_v4_signature(string_to_sign, secret_key, authorization);
  }
}

// Stand in for the standard verify callout, which calls the authenticator
// using HTTP. Here, we'll unpack the request and call the signature
// implementation ourselves, package a JSON response and return it in the
// provided bufferlist.
//
// As the real function, we return our result struct appropriately filled, and
// on success we put the reply markup for the caller in the bufferlist.
static rgw::HandoffHTTPVerifyResult http_verify_by_func(const DoutPrefixProvider* dpp, const std::string& request_json, ceph::bufferlist* resp_bl, [[maybe_unused]] optional_yield y)
{

  JSONParser parser;
  if (!parser.parse(request_json.c_str(), request_json.size())) {
    std::cerr << "Unable to parse request JSON" << std::endl;
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  std::string string_to_sign_base64;
  std::string access_key_id;
  std::string authorization;
  try {
    JSONDecoder::decode_json("stringToSign", string_to_sign_base64, &parser, true);
    JSONDecoder::decode_json("accessKeyId", access_key_id, &parser, true);
    JSONDecoder::decode_json("authorization", authorization, &parser, true);

  } catch (const JSONDecoder::err& err) {
    std::cerr << "request parse error: " << err.what() << std::endl;
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  std::string string_to_sign = rgw::from_base64(string_to_sign_base64);

  auto info = info_for_credential(access_key_id);
  if (!info) {
    return rgw::HandoffHTTPVerifyResult(-EACCES, 404);
  }
  auto secret = (*info).secret;
  // std::cerr << fmt::format(FMT_STRING("verify_by_func(): string_to_sign='{}' access_key_id='{}' secret_key='{}' authorization='{}'"), string_to_sign, access_key_id, secret, authorization) << std::endl;

  auto gen_signature = verify_aws_signature(string_to_sign, secret, authorization);
  std::string message;
  if (gen_signature.has_value()) {
    message = "OK";
  } else {
    return rgw::HandoffHTTPVerifyResult(-EACCES, 401);
  }

  // We only need to create the response body if we're about to return
  // success.

  JSONFormatter jf { true };
  jf.open_object_section(""); // root
  encode_json("message", message, &jf);
  encode_json("uid", (*info).userid, &jf);
  jf.close_section(); // root
  std::ostringstream oss;
  jf.flush(oss);

  resp_bl->append(oss.str());

  return rgw::HandoffHTTPVerifyResult(0, 200);
}

// Minimal client for req_state.
class TestClient : public rgw::io::BasicClient {
  RGWEnv env;

protected:
  virtual int init_env(CephContext* cct) override
  {
    return 0;
  }

public:
  virtual RGWEnv& get_env() noexcept override
  {
    return env;
  }

  virtual size_t complete_request() override
  {
    return 0;
  }
};

/* #endregion */

using namespace rgw;

/*
 * File-local framework tests.
 */

// Test the local signature implementation with known-good signature data.
TEST(HandoffMeta, SigPositive)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature(s2s, (*info).secret, t.authorization);
    ASSERT_TRUE(sig);
  }
}

TEST(HandoffMeta, SigNegative)
{
  for (const auto& t : sigpass_tests) {
    auto info = info_for_credential(t.access_key);
    ASSERT_TRUE(info) << "No secret found for " << t.access_key;
    auto s2s = rgw::from_base64(t.ss_base64);
    auto sig = verify_aws_signature("0" + s2s, (*info).secret, t.authorization);
    ASSERT_FALSE(sig);
    sig = verify_aws_signature(t.ss_base64, (*info).secret + "0", t.authorization);
    ASSERT_FALSE(sig);
  }
}

/*
 * HandoffHelper tests.
 */

TEST(HandoffHelper, Init)
{
  HandoffHelper hh;
  ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
}

/* #region HandoffHelperImplHTTP tests */

/**
 * @brief HTTP-mode HandoffHelperImpl end-to-end test fixture.
 *
 * Not using a parameterised test for HTTP and gRPC because I anticipate
 * removing the HTTP mode at some point, and it will be a pain to unpick.
 * Plus, the test harnesses for HTTP and gRPC are quite different.
 */
class HandoffHelperImplHTTPTest : public ::testing::Test {
protected:
  void SetUp() override
  {
    dpp.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "false");
    dpp.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp.get_cct()->_conf->rgw_handoff_enable_grpc, false);
    ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
  }

  HandoffHelperImpl hh { http_verify_by_func };
  optional_yield y = null_yield;
  DoutPrefix dpp { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

// Fail properly when the Authorization header is absent and one can't be
// synthesized.
TEST_F(HandoffHelperImplHTTPTest, FailIfMissingAuthorizationHeader)
{
  TestClient cio;

  auto t = sigpass_tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

TEST_F(HandoffHelperImplHTTPTest, SignatureV2CanBeDisabled)
{
  // // XXX I can't get the configuration observer to work in the harness.
  // // Luckily there are methods on the helperimpl that I can call directly.

  auto t = v2_sample;

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  ldpp_dout(&dpp, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  // This is what the config observer would call.
  hh.set_signature_v2(dpp.get_cct(), true);
  auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_ok());

  // dpp.get_cct()->_conf->rgw_handoff_enable_signature_v2 = false;
  // dpp.get_cct()->_conf.apply_changes(nullptr);
  hh.set_signature_v2(dpp.get_cct(), false);
  res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_err());

  // dpp.get_cct()->_conf->rgw_handoff_enable_signature_v2 = true;
  // dpp.get_cct()->_conf.apply_changes(nullptr);
  hh.set_signature_v2(dpp.get_cct(), true);
  res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
  ASSERT_TRUE(res.is_ok());
}

// Test working signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplHTTPTest, HeaderHappyPath)
{
  for (const auto& t : sigpass_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
    ASSERT_TRUE(res.is_ok()) << "should pass test '" << t.name << "'";
  }
}

// Test deliberately broken signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplHTTPTest, HeaderExpectBadSignature)
{
  for (const auto& t : sigfail_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh.auth(&dpp, "", t.access_key, string_to_sign, t.signature, &s, y);
    ASSERT_FALSE(res.is_ok()) << "should fail test '" << t.name << "'";
  }
}

/* #endregion HandoffHelperImplHTTP tests */

/* #region HandoffHelperImplGRPC tests */

class TestAuthImpl final : public authenticator::v1::AuthenticatorService::Service {

  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest gRPC server " };

  // Save some typing. This is an enum in S3ErrorDetails.
  using s3err_type = authenticator::v1::S3ErrorDetails::Type;

  grpc::Status grpc_error(grpc::StatusCode grpc_code, s3err_type type, int http_code, const std::string& message)
  {
    // This incantation is extracted from example code found here:
    // https://github.com/grpc/grpc/blob/master/examples/cpp/error_details/greeter_server.cc,
    // referenced from the 'Richer error model' doc
    // (https://grpc.io/docs/guides/error/).
    //
    // Create an S3ErrorDetails object containing details RGW will need, and
    // pack it into a grpc::Status object returnable by this method.

    authenticator::v1::S3ErrorDetails err;
    err.set_type(type);
    // err.set_http_code(http_code);
    // err.set_message(message);
    authenticator::v1::S3ErrorDetails s3errordetails;
    s3errordetails.set_type(type);
    s3errordetails.set_http_status_code(http_code);

    ::google::rpc::Status s;
    s.set_code(grpc_code);
    s.set_message(message);
    s.add_details()->PackFrom(s3errordetails);
    return grpc::Status { grpc_code, message, s.SerializeAsString() };
  }

  // Very simple implementation of the auth service. XXX Isn't as careful with
  // return codes as it could be, and returns no authorization-related codes.
  grpc::Status AuthenticateREST(grpc::ServerContext* context, const authenticator::v1::AuthenticateRESTRequest* request, authenticator::v1::AuthenticateRESTResponse* response) override
  {
    ldpp_dout(&dpp_, 20) << __func__ << ": enter" << dendl;

    auto maybe_akid = extract_access_key_id_from_authorization_header(request->authorization_header());
    if (!maybe_akid) {
      ldpp_dout(&dpp_, 20) << __func__ << ": unable to extract access key from authorization header" << dendl;
      return grpc_error(grpc::StatusCode::INVALID_ARGUMENT, s3err_type::S3ErrorDetails_Type_TYPE_AUTHORIZATION_HEADER_MALFORMED, 400, "unable to extract access key from authorization header");
    }
    auto access_key_id = *maybe_akid;

    // Use our pre-canned authentication database.
    auto info = info_for_credential(access_key_id);
    if (!info) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit CREDENTIALS NOT FOUND" << dendl;
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_INVALID_ACCESS_KEY_ID, 403, "credentials not found");
    }
    auto sig = verify_aws_signature(request->string_to_sign(),
        info->secret,
        request->authorization_header());
    if (!sig) {
      ldpp_dout(&dpp_, 20) << __func__ << ": exit SIGNATURE MISMATCH" << dendl;
      return grpc_error(grpc::StatusCode::UNAUTHENTICATED, s3err_type::S3ErrorDetails_Type_TYPE_SIGNATURE_DOES_NOT_MATCH, 403, "signature mismatch");
    }
    response->set_user_id(info->userid);
    ldpp_dout(&dpp_, 20) << __func__ << ": exit OK" << dendl;
    return grpc::Status::OK;
  }
};

/**
 * @brief gRPC mode HandoffHelperImpl end-to-end test fixture.
 *
 * Not using a parameterised test for HTTP and gRPC because I anticipate
 * removing the HTTP mode at some point, and it will be a pain to unpick
 * later. Also, the harness classes are very different and it will become
 * spaghettified if I try to combine them.
 *
 * However: As long as both HTTP and gRPC are in the codebase there is some
 * duplication here in the tests themselves. At least they can reuse the test
 * vectors.
 *
 * Use GRPCTestServer to implement the gRPC server on a random port, then
 * configure the HandoffHelperImpl to use it. The tests then issue gRPC()
 * calls against the helper.
 *
 * You *MUST* call helper_init() if you're going to use the HandoffHelperImpl
 * at all! Otherwise the channel and store won't be set up. This isn't called
 * automatically because sometimes we want to modify the channel configuration
 * first.
 *
 * It also doesn't implicitly start the server, you have to call start_test().
 * This is so we can easily test behaviour when the server isn't started.
 *
 * This actual-server approach has the virtue of being a somewhat faithful
 * client-side test. The server side is rather simplistic, obviously; but
 * that's probably ok.
 *
 * The fixture _will_ call server().stop() in TearDown, that feels relatively
 * safe.
 */
class HandoffHelperImplGRPCTest : public ::testing::Test {

protected:
  HandoffHelperImpl hh_;
  optional_yield y_ = null_yield;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };

  // This manages the test gRPC server.
  GRPCTestServer<TestAuthImpl> server_;

  // Don't start the server - some tests might want a chance to see what
  // happens without a server.
  void SetUp() override
  {
  }

  void helper_init()
  {
    dpp_.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "true");
    dpp_.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    // Note init() can take the server address URI, it's normally defaulted to
    // empty which means 'use the Ceph configuration'.
    ASSERT_EQ(hh_.init(g_ceph_context, nullptr, server_.address()), 0);
  }

  // Will stop the server. There's no situation where we want it left around.
  void TearDown() override
  {
    server().stop();
  }

  /// Return the gRPC server manager instance.
  GRPCTestServer<TestAuthImpl>& server() { return server_; }
};

// This just tests we can instantiate the test classes.
TEST_F(HandoffHelperImplGRPCTest, Null)
{
}

// Make sure server().start() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStart)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().start();
  }
  server().stop();
}

// Make sure server().stop() is idempotent.
TEST_F(HandoffHelperImplGRPCTest, MetaStop)
{
  server().start();
  for (int n = 0; n < 1000; n++) {
    server().stop();
  }
}

// Fail properly when the Authorization header is absent and one can't be
// synthesized.
TEST_F(HandoffHelperImplGRPCTest, FailIfMissingAuthorizationHeader)
{
  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_EQ(res.code(), -EACCES);
  ASSERT_THAT(res.message(), testing::ContainsRegex("missing Authorization"));
}

TEST_F(HandoffHelperImplGRPCTest, SignatureV2CanBeDisabled)
{
  // // XXX I can't get the configuration observer to work in the harness.
  // // Luckily there are methods on the helperimpl that I can call directly.

  server().start();
  helper_init();

  auto t = v2_sample;

  TestClient cio;
  // Set headers in the cio's env, not rgw_env (below).
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  // This is what the config observer would call.
  hh_.set_signature_v2(dpp_.get_cct(), true);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = false;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), false);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_err());

  // dpp_.get_cct()->_conf->rgw_handoff_enable_signature_v2 = true;
  // dpp_.get_cct()->_conf.apply_changes(nullptr);
  hh_.set_signature_v2(dpp_.get_cct(), true);
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok());
}

// Test working signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderHappyPath)
{
  server().start();
  helper_init();

  for (const auto& t : sigpass_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_TRUE(res.is_ok()) << "should pass test '" << t.name << "'";
  }
}

// Test deliberately broken signatures with the verify_by_func handler above.
TEST_F(HandoffHelperImplGRPCTest, HeaderExpectBadSignature)
{
  server().start();
  helper_init();

  for (const auto& t : sigfail_tests) {
    TestClient cio;
    // Set headers in the cio's env, not rgw_env (below).
    cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
    ldpp_dout(&dpp_, 20) << fmt::format(FMT_STRING("Auth: {}"), t.authorization) << dendl;

    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    s.cio = &cio;
    auto string_to_sign = rgw::from_base64(t.ss_base64);
    auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
    EXPECT_FALSE(res.is_ok()) << "should fail test '" << t.name << "'";
  }
}

// This is hardcoded in the library, you can't configure a reconnect delay
// less than 100ms. (grpc src/core/ext/filters/client_channel/subchannel.cc
// function ParseArgsForBackoffValues().) This allows five more milliseconds.
//
constexpr int SMALLEST_RECONNECT_DELAY_MS = 105;

// Check the system doesn't fail if started with a non-functional auth server.
TEST_F(HandoffHelperImplGRPCTest, ChannelRecoversFromDeadAtStartup)
{
  ceph_assert(g_ceph_context != nullptr);
  // Set everything to 1ms. As descrived for SMALLEST_RECONNECT_DELAY_MS,
  // we'll still have to wait 100ms + a few more millis for any reconnect.
  auto args = hh_.get_default_channel_args(g_ceph_context);
  args.SetInt(GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MIN_RECONNECT_BACKOFF_MS, 1);
  args.SetInt(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1);
  // // This is an alternate means of setting the reconnect delay, but it too
  // // bounded below at 100ms by the library.
  // args.SetInt("grpc.testing.fixed_fixed_reconnect_backoff_ms", 0);
  // Program the helper's channel.
  hh_.set_channel_args(dpp_.get_cct(), args);

  helper_init();
  TestClient cio;

  auto t = sigpass_tests[0];
  cio.get_env().set("HTTP_AUTHORIZATION", t.authorization);
  RGWEnv rgw_env;
  req_state s { g_ceph_context, &rgw_env, 0 };
  s.cio = &cio;
  auto string_to_sign = rgw::from_base64(t.ss_base64);
  auto res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  ASSERT_FALSE(res.is_ok()) << "should fail";
  ASSERT_EQ(res.code(), -EACCES) << "should return -EACCES";
  ASSERT_EQ(res.err_type(), HandoffAuthResult::error_type::TRANSPORT_ERROR) << "should return TRANSPORT_ERROR";

  server().start();
  // Wait as short a time as the library allows.
  std::this_thread::sleep_for(std::chrono::milliseconds(SMALLEST_RECONNECT_DELAY_MS));
  res = hh_.auth(&dpp_, "", t.access_key, string_to_sign, t.signature, &s, y_);
  EXPECT_TRUE(res.is_ok()) << "should now succeed";
  EXPECT_EQ(res.err_type(), HandoffAuthResult::error_type::NO_ERROR) << "should now show no error";
}

/* #endregion HandoffHelperImplGRPC tests */

/* #region PresignedTestData */

struct HandoffHeaderSynthData {
  std::string name;
  std::string url;
  std::string header;
};

static HandoffHeaderSynthData synth_pass[] = {
  // All use credential 0555b35654ad1656d804, the RGW test user.

  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600`. No region.
  {
      "aws s3 GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=XukLh8ZYkh7LhfDNGGPEznT5qMk%3D&Expires=1697103292",
      "AWS 0555b35654ad1656d804:XukLh8ZYkh7LhfDNGGPEznT5qMk=",
  },
  // `aws --endpoint-url='http://amygdala-ub01.home.ae-35.com:8000' s3 presign
  // s3://testnv/rand --expires 3600 --region eu-west-2`. Non-default region.
  {
      "aws s3 GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T083736Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=d63f2167860f1f3a02b098988cbe9e7cf19e2d3208044e70d52bcc88985abb17",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 signurl
  // s3://testnv/rand +3600`. No region. No --host-bucket set.
  {
      "s3cmd signurl GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697103824&Signature=2X2H46QEM73dL8EAHiWTgpEUYqs%3D",
      "AWS 0555b35654ad1656d804:2X2H46QEM73dL8EAHiWTgpEUYqs=",
  },
  // `s3cmd --host http://amygdala-ub01.home.ae-35.com:8000 --region eu-west-2
  // signurl s3://testnv/rand +3600`. Non-default region. No --host-bucket
  // set. Note s3cmd didn't switch to the 'v4-ish' presigned URL format.
  {
      "s3cmd signurl GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697110701&Signature=1QoTXjLEU3oh0LTfRn5wrccgWWw%3D",
      "AWS 0555b35654ad1656d804:1QoTXjLEU3oh0LTfRn5wrccgWWw=" },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000 testnv rand get --expiry 3600`. No region.
  {
      "presigned_url.py GET no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=EqiVBEaa%2B9wUIpHUw26ph74Pq4o%3D&Expires=1697110900",
      "AWS 0555b35654ad1656d804:EqiVBEaa+9wUIpHUw26ph74Pq4o=",
  },

  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand get --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py GET with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T104359Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=a54b4ae7a782c395ef8a75a0fbaf23f6d4a8e6d52d06cdc358be03344dd439b4",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600`. No region.
  {
      "presigned_url.py PUT no region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Signature=ob%2FzEMUCnhQyX1KE6vhGo0oSZq4%3D&Expires=1697107623",
      "AWS 0555b35654ad1656d804:ob/zEMUCnhQyX1KE6vhGo0oSZq4=",
  },
  // `presigned_url.py --endpoint http://amygdala-ub01.home.ae-35.com:8000
  // testnv rand put --expiry 3600 --region eu-west-2`. Non-default region.
  {
      "presigned_url.py PUT with region",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T094852Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
      "AWS4-HMAC-SHA256 Credential=0555b35654ad1656d804/20231012/eu-west-2/s3/aws4_request, SignedHeaders=host, Signature=cd8ed8099f8349c43bf1804bf3780ab0885e7c94baffcce65aacd34b4e6b6ade",
  }
};

/* #endregion */

/**
 * @brief HandoffHelperImpl test fixture. Not for end-to-end tests!
 */
class HandoffHelperImplSubsysTest : public ::testing::Test {
protected:
  void SetUp() override
  {
    // dpp.get_cct()->_conf.set_val_or_die("rgw_handoff_enable_grpc", "false");
    // dpp.get_cct()->_conf.apply_changes(nullptr);
    ASSERT_EQ(dpp.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    ASSERT_EQ(hh.init(g_ceph_context, nullptr), 0);
  }

  static rgw::HandoffHTTPVerifyResult verify_throw(const DoutPrefixProvider* dpp, const std::string& request_json, ceph::bufferlist* resp_bl, [[maybe_unused]] optional_yield y)
  {
    throw new std::runtime_error("Should not get here");
  }

  bool grpc_enabled;
  HandoffHelperImpl hh { verify_throw };
  optional_yield y = null_yield;
  DoutPrefix dpp { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

// Make sure we're properly creating the Authorization: header from query
// parameters. This is order-dependent; however every program I've tried it
// with (s3cmd, aws s3 presign, the AWS presigned_url.py SDK example code)
// respects this order.
TEST_F(HandoffHelperImplSubsysTest, PresignedSynthesizeHeader)
{
  for (auto const& t : synth_pass) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto got = hh.synthesize_auth_header(&dpp, &s);
    ASSERT_TRUE(got.has_value()) << t.name;
    EXPECT_EQ(*got, t.header) << t.name;
  }
}

/* #region HandoffConfigObserver */

/**
 * @brief Mock the chunks of HandoffHelperImpl we need to check that the
 * config observer is working properly.
 *
 * See the notes on HandoffConfigObserver<T> for more details. This class
 * allows us to instantiate a config observer and make sure it's responding
 * correctly to configuration changes.
 */
class MockHelperForConfigObserver final {
public:
  MockHelperForConfigObserver()
      : observer_(*this)
  {
  }
  ~MockHelperForConfigObserver() = default;

  int init(CephContext* const cct)
  {
    return 0;
  }
  grpc::ChannelArguments get_default_channel_args(CephContext* const cct)
  {
    return grpc::ChannelArguments();
  }
  void set_channel_args(CephContext* const cct, const grpc::ChannelArguments& args) { channel_args_set_ = true; }
  void set_channel_uri(CephContext* const cct, const std::string& uri) { channel_uri_ = uri; }
  void set_signature_v2(CephContext* const cct, bool enable) { signature_v2_ = enable; }
  void set_authorization_mode(CephContext* const cct, AuthParamMode mode) { authparam_mode_ = mode; }

public:
  HandoffConfigObserver<MockHelperForConfigObserver> observer_;
  AuthParamMode authparam_mode_;
  bool signature_v2_;
  bool channel_args_set_ = false;
  std::string channel_uri_;
};

/**
 * @brief Test that the config observer is hooked up properly for runtime
 * changes to variables we care about.
 */
class TestHandoffConfigObserver : public ::testing::Test {

protected:
  void SetUp() override
  {
    ASSERT_EQ(dpp_.get_cct()->_conf->rgw_handoff_enable_grpc, true);
    ASSERT_EQ(hh_.init(g_ceph_context), 0);
  }

  MockHelperForConfigObserver hh_;
  DoutPrefix dpp_ { g_ceph_context, ceph_subsys_rgw, "unittest " };
};

TEST_F(TestHandoffConfigObserver, Null)
{
}

TEST_F(TestHandoffConfigObserver, SignatureV2Mode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_enable_signature_v2" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_enable_signature_v2 = true;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.signature_v2_, true);

  conf->rgw_handoff_enable_signature_v2 = false;
  hh_.observer_.handle_conf_change(conf, changed);
  EXPECT_EQ(hh_.signature_v2_, false);
}

// Test that the config change propagates to the helper. We're not parsing the
// individual arg setting, that would mean essentially recreating the helper's
// code in the mock which is pointless.
//
// In all the test cases we'll call handle_conf_change() directly. I had
// problems getting the observer to work reliably in unit tests, whether I
// just relied on 'automatic' change application, or if I directly called
// conf.apply_changes(). It doesn't really matter - what we're testing here is
// that if handle_conf_change() is called properly, then the configuration
// will flow through to the helperimpl.
//
TEST_F(TestHandoffConfigObserver, GRPCChannelArgs)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed;

  std::set<std::string> param = {
    "rgw_handoff_grpc_arg_initial_reconnect_backoff_ms",
    "rgw_handoff_grpc_arg_min_reconnect_backoff_ms",
    "rgw_handoff_grpc_arg_max_reconnect_backoff_ms"
  };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  for (const auto& p : param) {
    hh_.channel_args_set_ = false;

    conf.set_val_or_die(p, "1001");
    changed.clear();
    changed.emplace(p);
    hh_.observer_.handle_conf_change(conf, changed);
    ASSERT_TRUE(hh_.channel_args_set_);
  }
}

TEST_F(TestHandoffConfigObserver, GRPCURI)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_grpc_uri" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  conf->rgw_handoff_grpc_uri = "foo";
  hh_.observer_.handle_conf_change(conf, changed);
  ASSERT_EQ(hh_.channel_uri_, "foo");
}

TEST_F(TestHandoffConfigObserver, AuthParamMode)
{
  // Parameters we'll 'change'.
  std::set<std::string> changed { "rgw_handoff_authparam_always", "rgw_handoff_authparam_withtoken" };

  auto cct = dpp_.get_cct();
  auto conf = cct->_conf;

  // Default -> 'ALWAYS'.
  conf->rgw_handoff_authparam_always = true;
  conf->rgw_handoff_authparam_withtoken = false;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::ALWAYS);

  // Both set -> 'ALWAYS'.
  conf->rgw_handoff_authparam_always = true;
  conf->rgw_handoff_authparam_withtoken = true;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::ALWAYS);

  // Partial -> 'WITHTOKEN'.
  conf->rgw_handoff_authparam_always = false;
  conf->rgw_handoff_authparam_withtoken = true;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::WITHTOKEN);

  // Never -> 'NEVER'.
  conf->rgw_handoff_authparam_always = false;
  conf->rgw_handoff_authparam_withtoken = false;
  hh_.observer_.handle_conf_change(conf, changed);
  // hh_.set_authorization_mode(cct, hh_.observer_.get_authorization_mode(conf));
  EXPECT_EQ(hh_.observer_.get_authorization_mode(conf), AuthParamMode::NEVER);
}

/* #endregion HandoffConfigObserver */

/* #region PresignedExpiryData */

struct PresignedExpiryData {
  std::string name;
  std::string url;
  time_t now;
  time_t delta;
};

static PresignedExpiryData expiry_unit[] = {
  {
      // Basic GET, v2 syntax (no region).
      // `s3cmd --host http://amygdala.home.ae-35.com:8000 signurl s3://testnv/rand +60`
      "s3cmd signurl +60",
      "http://amygdala-ub01.home.ae-35.com:8000/testnv/rand?AWSAccessKeyId=0555b35654ad1656d804&Expires=1697122817&Signature=2HxhmxDYl0WgfktL0L62GVC%2B9vY%3D",
      1697122757,
      60,
  },
  {
      // Basic GET, v4 syntax (region).
      // `aws --endpoint-url=http://amygdala.home.ae-35.com:8000 s3 presign
      // s3://testnv/rand --expires 60 --region eu-west-2`
      "aws s3 presign +60 region",
      "http://amygdala.home.ae-35.com:8000/testnv/rand?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=0555b35654ad1656d804%2F20231012%2Feu-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T153745Z&X-Amz-Expires=60&X-Amz-SignedHeaders=host&X-Amz-Signature=050fcdc4e6f7046776b36a869ad428c68ffb7dbba807af18f146ca3923b21e2f",
      1697125065,
      60,
  }
};

/* #endregion */

// Presigned headers have an expiry time. If we're past that time, we
// shouldn't even pass the request to the Authenticator.
TEST_F(HandoffHelperImplSubsysTest, PresignedCheckExpiry)
{
  for (auto const& t : expiry_unit) {

    // We need a req_state struct to pass to synthesize_auth_header(), so
    // implement the pieces of RGWHandler_REST_S3::init_from_header() that we
    // care about, taking the test URL as input.
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };
    // In the input URL, skip to the '?' marking the start of URL parameters.
    // (This is what init_from_header() does.)
    auto p = t.url.c_str();
    for (auto c : t.url) {
      if (c == '?') {
        break;
      }
      p++;
    }
    ASSERT_TRUE(*p != 0) << t.name;
    // Parse arguments from the URL.
    s.info.args.set(p);
    s.info.args.parse(&s);
    // End init_from_header() mock.

    auto actual = hh.valid_presigned_time(&dpp, &s, t.now);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta);
    EXPECT_EQ(actual, true) << t.name << ": expect pass (t==now+delta)";
    actual = hh.valid_presigned_time(&dpp, &s, t.now + t.delta + 1);
    EXPECT_EQ(actual, false) << t.name << ": expect fail (t==now+delta+1)";
  }
}

/* #region AuthorizationParametersTestData */

struct AuthorizationConstructTest {
  std::string method;
  // Note that the r_uri is used as s->relative_uri. We don't have to worry
  // about URL encoding of the bucket and keys. Why? In
  // RGWREST::get_handler(), we do RGWREST::preprocess() which fills in
  // s->decoded_uri, and immediately s->decoded_uri is used to initialise the
  // RGWRestMgr, whose out parameter is s->relative_uri.
  //
  std::string r_uri;
  bool expected_pass;
  std::string exp_method;
  std::string exp_bucket;
  std::string exp_object_key;
};

static AuthorizationConstructTest eak_unit[] = {
  // Simple get.
  { "GET", "/bucket/key", true, "GET", "bucket", "key" },
  // Simple put.
  { "PUT", "/bucket/key", true, "PUT", "bucket", "key" },
  // Get with non-ASCII7 key. Essentially a no-op because we get the URL
  // post-decoding.
  { "GET", "/foo/Dj vu", true, "GET", "foo", "Dj vu" },
  // Get for ls (i.e. no key).
  { "GET", "/bucket", true, "GET", "bucket", "" },
  // Broken: No method.
  { "", "/bucket", false, "", "", "" },
  // Broken: No bucket or key.
  { "GET", "/", true, "GET", "", "" },
};

/* #endregion */

TEST_F(HandoffHelperImplSubsysTest, AuthorizationParamConstruct)
{
  for (const auto& t : eak_unit) {
    RGWEnv rgw_env;
    req_state s { g_ceph_context, &rgw_env, 0 };

    TestClient cio;
    // Set a header that should be included in the params.
    cio.get_env().set("HTTP_X_AMZ_FOO", "bar");
    s.cio = &cio;

    auto test_desc = fmt::format(FMT_STRING("for test: {} {} exp:{}"), t.method, t.r_uri, t.expected_pass);
    s.info.method = t.method.c_str();
    s.relative_uri = t.r_uri;

    auto param = rgw::AuthorizationParameters(&dpp, &s);

    if (!t.expected_pass) {
      EXPECT_FALSE(param.valid()) << test_desc;
      EXPECT_ANY_THROW(param.method()) << test_desc;
      EXPECT_ANY_THROW(param.bucket_name()) << test_desc;
      EXPECT_ANY_THROW(param.object_key_name()) << test_desc;
    } else {
      ASSERT_TRUE(param.valid()) << test_desc;
      EXPECT_EQ(param.method(), t.exp_method) << test_desc;
      EXPECT_EQ(param.bucket_name(), t.exp_bucket) << test_desc;
      EXPECT_EQ(param.object_key_name(), t.exp_object_key) << test_desc;
      // Any valid request should have the headers.
      ASSERT_NE(param.http_headers().find("x-amz-foo"), param.http_headers().end()) << test_desc;
      EXPECT_EQ(param.http_headers().at("x-amz-foo"), "bar") << test_desc;
    }
  }
}

// Test AuthServiceClient::_translate_authenticator_error_code().
TEST_F(HandoffHelperImplSubsysTest, TestReturnCodeMapping)
{
  // There's no need to be exhausive here, that's just copying an array or
  // implementing a big switch. Check a few representative values, and check
  // the cases where there's no mapping to make sure we're properly
  // defaulting.

  using err_type = S3ErrorDetails::Type;
  HandoffAuthResult res { "testid", "bar" };

  // Test a sample of standard responses.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_ACCESS_DENIED, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_AUTHORIZATION_HEADER_MALFORMED, 400, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_INVALID_REQUEST);
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_SIGNATURE_DOES_NOT_MATCH, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_SIGNATURE_NO_MATCH);

  // Test the way we handle the 'no mapping' case.

  // Unspecified (no mapping), request a 403. We should get an 'EACCES'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 403, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
  // Unspecified (no mapping), request a 400. We should get an 'EINVAL'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 400, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EINVAL);
  // Unspecified (no mapping), request a 404. We should get an 'ERR_NOT_FOUND'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 404, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), ERR_NOT_FOUND);
  // Unspecified (no mapping), request a 666 (nonsense code). We should get an 'EACCES'.
  res = AuthServiceClient::_translate_authenticator_error_code(err_type::S3ErrorDetails_Type_TYPE_UNSPECIFIED, 666, "foo");
  ASSERT_TRUE(res.is_err());
  EXPECT_EQ(res.code(), EACCES);
}

} // namespace rgw

// main() cribbed from test_http_manager.cc

int main(int argc, char** argv)
{
  auto args = argv_to_vec(argc, argv);
  auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT, CODE_ENVIRONMENT_UTILITY, CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);
  common_init_finish(g_ceph_context);

  // These can most likely go when HTTP mode is removed.
  rgw_http_client_init(cct->get());
  rgw_setup_saved_curl_handles();

  // Let the caller change the library debug level.
  if (std::getenv("TEST_DEBUG")) {
    std::string err;
    int level = strict_strtol(std::getenv("TEST_DEBUG"), 10, &err);
    if (err.empty()) {
      g_ceph_context->_conf->subsys.set_log_level(ceph_subsys_rgw, std::min(level, 30));
    }
  }

  ::testing::InitGoogleTest(&argc, argv);
  int r = RUN_ALL_TESTS();

  // These can most likely go when HTTP mode is removed.
  rgw_release_all_curl_handles();
  rgw_http_client_cleanup();

  return r;
}
